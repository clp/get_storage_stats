#! /usr/bin/env perl
#
use strict;
use warnings;

# use Getopt::Long;

use Data::Dumper;

#TBD use Parse::StorageArrayLog;

our $VERSION = '0.05';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any

my $input_file = $ARGV[0];

unless ($input_file) {
    die "No input_file found on command line\n\n", usage();
}

my %stats;
my $volname;

# The main data structure is a hash of hashes.
# Each key in the HoH is a volname; the value is a ref to a data hash.
# Each data hash has keys for the 7 field names; and their values.


# Read entire file & get volnames.
while (<>) {
    chomp;
    if ( m/Volume name:\s+(\S+)/ ) {
        $volname = $1;
        $stats{$volname}{volname} = $volname  ;
        next;
    }
}


# Process the i/p file again, after volnames have been found,
# to get other data fields.
#
# Note: 
# The field used here for hostname is really domain name, 
# which need not be the same as the hostname.  This solution
# is OK for now, according to the user.
my $infile;
open $infile, '<', $input_file  or die "Cannot open $input_file: $!";
while (<$infile>) {
    chomp;
    if ( m/^(\S+)\s+(\d+)\s+Tray\S+\s+(\S+)\s+\S+\s+$/ ) {
        my $volname = $1;
        my $lun  = $2;
        my $hostname  = $3;
        $stats{$volname}{hostname} = $hostname  ;
        $stats{$volname}{lun} = $lun  ;
        next;
    }

    if ( m/(\S+)\s+\w+\s+([\d,.]+ \s \w+)\s+ 
            (RAID \s \d+) \s+\w+\s+(\S+)\s*/smx ) {
        my $volname = $1;
        my $capacity  = $2;
        my $raid  = $3;
        my $pool  = $4;
        $stats{$volname}{capacity} = $capacity  ;
        $stats{$volname}{raid} = $raid  ;
        $stats{$volname}{pool} = $pool  ;
        next;
    }
}


seek ($infile, 0, 0); # Return to start of input file.

$/ = ''; # Read one paragraph at a time.

while (<$infile>) {
    chomp;
    if ( m/\s+ Volume.name:\s+ (\S+).*  # .*  gets anything including newline,
                                        # until next anchor text (Volume.WWN).
            Volume.WWN: \s+(\S+) .*     # Capture value of WWN 
            Status:/msx ) {             # /s: allows dot to match newline.
        my $volname = $1;
        my $wwn  = $2;
        $stats{$volname}{wwn} = $wwn  ;
        next;
    }
}


# Sort on 2 keys: first hostname, then lun.
print "Hostname, LUN, Volume Name, Capacity, RAID level, Pool, WWN\n";
    my @unsorted_volnames = map { $stats{$_}->{volname} } keys %stats;
    my @sorted_host_lun;
    @sorted_host_lun = sort 
            { $stats{$a}{hostname} cmp $stats{$b}{hostname}
                                    ||
              $stats{$a}{lun} <=> $stats{$b}{lun}
            } @unsorted_volnames;
    foreach my $v ( @sorted_host_lun ) {
        print $stats{$v}{hostname}, ", ";
        print $stats{$v}{lun}, ", ";
        print $stats{$v}{volname}, ", ";
        print $stats{$v}{capacity}, ", ";
        print $stats{$v}{raid}, ", ";
        print $stats{$v}{pool}, ", ";
        print $stats{$v}{wwn}, "\n";
    }


exit;


sub usage {
    return <<"eousage";
Usage
  $prog <input_file>

$prog is a filter for storage array status files.
It searches for volume names and presents data about them.

Only one input file is allowed for each run of the program.

eousage
}


#TBD: Sample data: RAID line:
# rxsg102-zoneroots       	Optimal	50 GB       	RAID 5    	24   	FCRaid5              	
# rssg101-smbzfs-dev      	Optimal	1,394.482 GB	RAID 5    	26   	FCRaid5              	
#TBD: Sample data: Tray line:
# rssg111-smbzfs-dev      	2  	Tray.85.Controller.A	cal-rssg111           	Optimal      	
#TBD: Sample data: WWN data:
# Volume name: rssg101-smbzfs-dev
      # Volume handle: 25
      # Volume WWN: BOGUSB800047644600000C0F49DBOGUS
      # Status: Optimal

