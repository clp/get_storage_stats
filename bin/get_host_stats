#! /usr/bin/env perl

# Main data structure is an array of refs to hashes.
# Each array elt is a volname, which is a ref to a hash.
# Each hash has keys for the 7 field names, and corresponding values.
#
use strict;
use warnings;

# use Getopt::Long;

use Data::Dumper;

#TBD use Parse::StorageArrayLog;

our $VERSION = '0.05';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any

#TBD: Temp fix; assume only one arg on cmd line: i/p file name.
# Cannot specify multiple i/p files w/ this fix.
my $input_file = $ARGV[0];

unless ($input_file) {
    die "no input_file found on command line\n\n", usage();
}

my @hosts;
my %stats;
my $volname;


# Read entire file & get volnames.
while (<>) {
    chomp;
    #DBG print "DBG: \$_: ,$_,\n";
    if ( m/Volume name:\s+(\S+)/ ) {
        $volname = $1;
        #DBG print "DBG-Tray regex: \$volname: ,$volname,\n";
        $stats{$volname}{volname} = $volname  ;
        next;
    }
}  # End while #1.


#TBD: Process the i/p file again, after volnames have been found.
my $infile;
open $infile, '<', $input_file  or die "Cannot open $input_file: $!";
while (<$infile>) {
    chomp;
    if ( m/^(\S+)\s+(\d+)\s+Tray\S+\s+(\S+)\s+\S+\s+$/ ) {
        my $volname = $1;
        my $lun  = $2;
        my $hostname  = $3;
        $stats{$volname}{hostname} = $hostname  ;
        $stats{$volname}{volname} = $volname  ;
        $stats{$volname}{lun} = $lun  ;
        next;
    }

    if ( m/(\S+)\s+\w+\s+([\d,.]+ \s \w+)\s+ (RAID \s \d+) \s+\w+\s+(\S+)\s*/smx ) {
        my $volname = $1;
        my $capacity  = $2;
        my $raid  = $3;
        my $pool  = $4;
        $stats{$volname}{capacity} = $capacity  ;
        $stats{$volname}{raid} = $raid  ;
        $stats{$volname}{pool} = $pool  ;
        next;
    }
}  # End while #2.


# Read one paragraph at a time.
$/ = '';
open $infile, '<', $input_file  or die "Cannot open $input_file: $!";
while (<$infile>) {
    chomp;
    if ( m/\s+ Volume.name:\s+ (\S+).*       # .*  gets anything including newline,
                                             #   until next anchor text (Volume.WWN).
      Volume.WWN: \s+(\S+) .*                # Capture value of WWN 
      Status:/msx ) {                        # /s: allows dot to match newline.
        my $volname = $1;
        my $wwn  = $2;
        $stats{$volname}{volname} = $volname  ;
        $stats{$volname}{wwn} = $wwn  ;
        next;
    }
}  # End while() #3.


# Sort on 2 keys: first hostname, then lun.
print "Hostname, LUN, Volume Name, Capacity, RAID level, Pool, WWN\n";
    my @unsorted_volnames = map { $stats{$_}->{volname} } keys %stats;
    my @sorted_host_lun;
    @sorted_host_lun = sort 
            { $stats{$a}{hostname} cmp $stats{$b}{hostname}
                                    ||
              $stats{$a}{lun} <=> $stats{$b}{lun}
            } @unsorted_volnames;
    foreach my $v ( @sorted_host_lun ) {
        print $stats{$v}{hostname}, ", ";
        print $stats{$v}{lun}, ", ";
        print $stats{$v}{volname}, ", ";
        print $stats{$v}{capacity}, ", ";
        print $stats{$v}{raid}, ", ";
        print $stats{$v}{pool}, ", ";
        print $stats{$v}{wwn}, "\n";
    }


exit;


sub usage {
    return <<"eousage";
Usage
  $prog <status_file>

$prog is a filter for storage array status files.
It searches for host and volume names and presents data about them.

eousage
}


#TBD: Sample data: RAID line:
# rxsg102-zoneroots       	Optimal	50 GB       	RAID 5    	24   	FCRaid5              	
# rssg101-smbzfs-dev      	Optimal	1,394.482 GB	RAID 5    	26   	FCRaid5              	
#TBD: Sample data: Tray line:
# rssg111-smbzfs-dev      	2  	Tray.85.Controller.A	cal-rssg111           	Optimal      	
#TBD: Sample data: WWN data:
# Volume name: rssg101-smbzfs-dev
      # Volume handle: 25
      # Volume WWN: BOGUSB800047644600000C0F49DBOGUS
      # Status: Optimal

