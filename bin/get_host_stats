#! /usr/bin/env perl

# Main data structure is an array of refs to hashes.
# Each array elt is a volname, which is a ref to a hash.
# Each hash has keys for the 7 field names, and corresponding values.
#
use strict;
use warnings;

# use Getopt::Long;

use Data::Dumper;

#TBD use Parse::StorageArrayLog;

our $VERSION = '0.03';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any

#TBD: Temp fix; assume only one arg on cmd line: i/p file name.
# Cannot specify multiple i/p files w/ this fix.
my $input_file = $ARGV[0];

#TBD unless ($input_file) {
    #TBD die "no input_file found on command line\n\n", usage();
#TBD }

my @hosts;
my @volumes;
my %stats;
my $volname;


# Read entire file & get volnames & fill @volumes array.
while (<>) {
    chomp;
    #DBG print "DBG: \$_: ,$_,\n";
    if ( m/Volume name:\s+(\S+)/ ) {
        $volname = $1;
        #DBG print "DBG-Tray regex: \$volname: ,$volname,\n";
        $stats{$volname}{volname} = $volname  ;
        push  @volumes, $stats{$volname};
        next;
    }
    if ( m/Host:\s+(\S+)/ ) {
        my $hostname = $1;
        #DBG print "DBG-Tray regex: \$volname: ,$volname,\n";
        #TBR $stats{$volname}{volname} = $volname  ;
        push  @hosts, $hostname;
        next;
    }
}  # End while #1.

# Match volname to core host name pattern.
foreach my $h (@hosts) {
    $h =~ s/^cal-//;
    $h =~ s/-.*$//;
    #DBG print "DBG: \$h: ,$h,\n";
    foreach my $v (@volumes) {
        #DBG print "DBG: \$v->{volname}: ", ,$v->{volname},, "\n";
        if ($v->{volname} =~ /$h/) {
            $stats{$v->{volname}}{hostname} = $h;
            #DBG print "DBG: \$h ... \$v->{volname}: ,$h ... $v->{volname},\n";
        }
    }
}


#TBD: Process the i/p file again, after @volumes has been filled.
my $infile;
open $infile, '<', $input_file  or die "Cannot open $input_file: $!";
while (<$infile>) {
    chomp;
    if ( m/^(\S+)\s+(\d+)\s+Tray\S+\s+(\S+)\s+\S+\s+$/ ) {
        my $volname = $1;
        my $lun  = $2;
        #TBR my $hostname  = $3;
        #TBR $stats{$volname}{hostname} = $hostname  ;
        $stats{$volname}{volname} = $volname  ;
        $stats{$volname}{lun} = $lun  ;
        next;
    }

    if ( m/(\S+)\s+\w+\s+([\d,.]+ \s \w+)\s+ (RAID \s \d+) \s+\w+\s+(\S+)\s*/smx ) {
        my $volname = $1;
        my $capacity  = $2;
        my $raid  = $3;
        my $pool  = $4;
        $stats{$volname}{capacity} = $capacity  ;
        $stats{$volname}{raid} = $raid  ;
        $stats{$volname}{pool} = $pool  ;
        next;
    }
}  # End while #2.


#TBD: Process the i/p file again, after @volumes has been filled.
# Read one paragraph at a time.
$/ = '';
open $infile, '<', $input_file  or die "Cannot open $input_file: $!";
while (<$infile>) {
    chomp;
    if ( m/\s+ Volume.name:\s+ (\S+).*?       # .*?  gets anything including newline,
                                              #   until next text (Volume.handle),
                                              #   in non-greedy mode (the '?' suffix)
      Volume.handle:\s+ \d+.*?                # Data to skip; TBR?: Remove this line?
      Volume.WWN: \s+(\S+) .*? Status:/msx ) {
        my $volname = $1;
        my $wwn  = $2;
        $stats{$volname}{volname} = $volname  ;
        $stats{$volname}{wwn} = $wwn  ;
        next;
    }
}  # End while() #3.


print "hostname, lun, volname, capacity, RAID level, pool, WWN\n\n";
foreach my $v (@volumes) {
    print $stats{$v->{volname}}{hostname}, ", ";
    print $stats{$v->{volname}}{lun}, ", ";
    print $stats{$v->{volname}}{volname}, ", ";
    print $stats{$v->{volname}}{capacity}, ", ";
    print $stats{$v->{volname}}{raid}, ", ";
    print $stats{$v->{volname}}{pool}, ", ";
    print $stats{$v->{volname}}{wwn}, "\n";
}

print "\n\n\n   Print sorted by volname.\n";
foreach my $v ( sort @volumes ) {
    print $stats{$v->{volname}}{hostname}, ", ";
    print $stats{$v->{volname}}{lun}, ", ";
    print $stats{$v->{volname}}{volname}, ", ";
    print $stats{$v->{volname}}{capacity}, ", ";
    print $stats{$v->{volname}}{raid}, ", ";
    print $stats{$v->{volname}}{pool}, ", ";
    print $stats{$v->{volname}}{wwn}, "\n";
}

exit;


sub usage {
    return <<"eousage";
usage $prog: [options] <log_files>

$prog is a filter for Storage Array TBD:config|status|log files.
It searches for host names and presents desired data about them.

Options to control the matching


Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}


#TBD: Sample data: RAID line:
# rxsg102-zoneroots       	Optimal	50 GB       	RAID 5    	24   	FCRaid5              	
# rssg101-smbzfs-dev      	Optimal	1,394.482 GB	RAID 5    	26   	FCRaid5              	
#TBD: Sample data: Tray line:
# rssg111-smbzfs-dev      	2  	Tray.85.Controller.A	cal-rssg111           	Optimal      	
#TBD: Sample data: WWN data:
# Volume name: rssg101-smbzfs-dev
      # Volume handle: 25
      # Volume WWN: 600A0B800047644600000C0F49D9B6BB
      # Status: Optimal

