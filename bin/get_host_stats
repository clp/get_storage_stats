#! /usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
$Data::Dumper::Useqq = 1; # important to be able to actually see differences in whitespace, etc

use Parse::StorageArrayLog qw/match_line match_paragraph/;

our $VERSION = '0.06';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any

my %stats;
my $volname;
my @infile = @ARGV; # Save i/p file for second read loop.
my $data_hash_ref;

unless (-r $ARGV[0]) {
    die "No readable input file found on command line\n\n", usage();
}

# The main data structure is a hash of hash references, %stats.
# Each key in the HoH is a volname; the value is a ref to a data hash.
# Each data hash has keys for the field names; and their values.


# Read loop 1: Process the i/p file by one line at a time.
#
while (<>) {
    chomp;
    ($volname, $data_hash_ref) = match_line( $_ );
    next if ( ! defined $data_hash_ref );
    next if ( $data_hash_ref eq '' );
    while ( my ($k, $v) = each %$data_hash_ref ) {
        $stats{ $volname } {$k} = $v;
    }
    next;
}


# Read loop 2: Re-open & process the i/p file by one paragraph at a time.
$/ = ''; # Read one paragraph at a time.
@ARGV = @infile;

while (<>) {
    chomp;
    ($volname, $data_hash_ref) = match_paragraph( $_ );
    next if ( ! defined $data_hash_ref );
    next if ( $data_hash_ref eq '' );
    while ( my ($k, $v) = each %$data_hash_ref ) {
        $stats{ $volname } {$k} = $v;
    }
    next;
}



# To print, sort on 2 keys: first hostname, then lun.
my @unsorted_volnames = map { $stats{$_}->{volname} } keys %stats;
my @sorted_host_lun = sort 
        { $stats{$a}{hostname} cmp $stats{$b}{hostname}
                                ||
          $stats{$a}{lun} <=> $stats{$b}{lun}
        } @unsorted_volnames;

my @columns = qw( hostname lun volname capacity raid pool wwn);
print "Hostname, LUN, Volume Name, Capacity, RAID level, Pool, WWN\n";
foreach my $v ( @sorted_host_lun ) {
    my @row = ();
    push @row , ( $stats{$v}{$columns[$_]}  ) for (0..$#columns);
    print  ( join(", ",   @row[0 .. ($#row-1)], $row[-1]) );
    print "\n";
}

exit;


sub usage {
    return <<"eousage";
Usage
  $prog <input_file>

$prog is a filter for storage array status files.
It searches for volume names and presents data about them.

Only one input file is allowed for each run of the program.

eousage
}


# Sample data: RAID line:
# rxsg102-zoneroots       	Optimal	50 GB       	RAID 5    	24   	FCRaid5              	
# rssg101-smbzfs-dev      	Optimal	1,394.482 GB	RAID 5    	26   	FCRaid5              	
#
# Sample data: Tray line:
# rssg111-smbzfs-dev      	2  	Tray.85.Controller.A	cal-rssg111           	Optimal      	
#
# Sample data: WWN data:
# Volume name: rssg101-smbzfs-dev
      # Volume handle: 25
      # Volume WWN: BOGUSB800047644600000C0F49DBOGUS
      # Status: Optimal

